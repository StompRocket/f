(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{"./guide.mdx":function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return d});var a=t("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"),o=t("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js"),s=t("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js"),m=t("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js"),r=t("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js"),p=t("./node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js"),i=t("./node_modules/react/index.js"),c=t.n(i),l=t("./node_modules/@mdx-js/tag/dist/index.js"),d=function(e){function n(e){var t;return Object(o.a)(this,n),(t=Object(m.a)(this,Object(r.a)(n).call(this,e))).layout=null,t}return Object(p.a)(n,e),Object(s.a)(n,[{key:"render",value:function(){var e=this.props,n=e.components;Object(a.a)(e,["components"]);return c.a.createElement(l.MDXTag,{name:"wrapper",components:n},c.a.createElement(l.MDXTag,{name:"h1",components:n,props:{id:"guide"}},"Guide"),c.a.createElement(l.MDXTag,{name:"p",components:n},"This page aims to provide a high-level guide to using f.js, and an introduction\nto functional programming concepts and how they can be applied to web design."),c.a.createElement(l.MDXTag,{name:"p",components:n},"There are two core principles that dictate how everything in f.js works."),c.a.createElement(l.MDXTag,{name:"ol",components:n},c.a.createElement(l.MDXTag,{name:"li",components:n,parentName:"ol"},"Everything is a function"),c.a.createElement(l.MDXTag,{name:"li",components:n,parentName:"ol"},"Changes to the model can only occur because of events.")),c.a.createElement(l.MDXTag,{name:"p",components:n},"Already it is obvious that f.js does not work like most frontend frameworks do.\nReact, Vue, etc. all try to create a way for the view to update based on changes\nto the data (or model). This is so difficult to achieve cleanly and quickly\nbecause of the imperative nature of the code these frameworks expect you to write.\nThere is no one known source of changes to the model, and because of this, complex\nmethods of handling these changes must be designed. In f.js, since the origin of\nall changes to the model is known, the runtime required is minimal, and more\nimportantly, developers can easily track down bugs."),c.a.createElement(l.MDXTag,{name:"h2",components:n,props:{id:"hello-world"}},"Hello, World!"),c.a.createElement(l.MDXTag,{name:"p",components:n},"Now that some of the benefits of f.js have been covered, what does an f.js app\nactually look like? Here is a hello world example in f.js:"),c.a.createElement(l.MDXTag,{name:"pre",components:n},c.a.createElement(l.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'import * as f from \'@stomprocket/f\'\n\nlet view = model =>\n  f.b\n    ( )\n    ( model.message )\n\nlet update = (e, model, body) => model\n\nf.render("#app", view, update, {\n  message: "Hello, World!"\n})\n')),c.a.createElement(l.MDXTag,{name:"p",components:n},"Already this looks pretty different from most frameworks. Let's go through it\npart by part."),c.a.createElement(l.MDXTag,{name:"h3",components:n,props:{id:"the-view"}},"The View"),c.a.createElement(l.MDXTag,{name:"p",components:n},"On line 3 a function view is declared, which takes a model as its only argument,\nand calls and returns a function ",c.a.createElement(l.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"f.b"),". The syntax is a bit different from what many\nJavaScript developers might be used to. Why are there two sets of arguments?\nWhere is the logic? It may be more understandable to express this in the regular,\nold JavaScript way, using plain old ",c.a.createElement(l.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"function"),"s."),c.a.createElement(l.MDXTag,{name:"pre",components:n},c.a.createElement(l.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"function view(model) {\n  return f.b()(model.message)\n}\n")),c.a.createElement(l.MDXTag,{name:"p",components:n},"The ",c.a.createElement(l.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"b")," function is the same as an HTML ",c.a.createElement(l.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"<b>")," tag in f.js. It takes two sets of\narguments, the first one being it's attributes, and the second, it's body. This\nis an abstraction over what the ",c.a.createElement(l.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"b")," function actually does, take some arguments\nas it's attributes, and return another function that will take arguments for its\nbody. You'll notice this pattern used everywhere in f.js. In fact, ",c.a.createElement(l.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"b")," itself\nis defined as"),c.a.createElement(l.MDXTag,{name:"pre",components:n},c.a.createElement(l.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},"const b = elem('b')\n")),c.a.createElement(l.MDXTag,{name:"p",components:n},"Which means the same code could be written as ",c.a.createElement(l.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"elem('b')()(model.message)"),".\nYou don't need to understand the intricacies of ",c.a.createElement(l.MDXTag,{name:"em",components:n,parentName:"p"},"why")," f.js is designed like this\njust yet, that will be covered a bit later."),c.a.createElement(l.MDXTag,{name:"h3",components:n,props:{id:"update"}},"Update"),c.a.createElement(l.MDXTag,{name:"p",components:n},"The ",c.a.createElement(l.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"update")," function is defined as taking three arguments, ",c.a.createElement(l.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"(e, model, body)")," and\nreturning the model. This function is responsible for handling all events. Since\nour app so far doesn't have any events, it simply returns the model unmodified."),c.a.createElement(l.MDXTag,{name:"h3",components:n,props:{id:"render"}},"Render"),c.a.createElement(l.MDXTag,{name:"p",components:n},"The ",c.a.createElement(l.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"render")," function takes a view, an updater function, and a starting model, and\nrenders them to a certain element, in this case ",c.a.createElement(l.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"#app"),". This function is pretty\nself explanatory, it just renders the view to the element it is told to. It\ndoesn't handle any events or anything itself, it just tells the view what to do\nwhen it has an event to emit. "),c.a.createElement(l.MDXTag,{name:"h2",components:n,props:{id:"components"}},"Components"),c.a.createElement(l.MDXTag,{name:"p",components:n},"Everything in f.js is a function, including components. There are two types\nof componenets. Simple styled components (ones that only contain certain\nattributes), or complex ones, that can handle rendering elaborate data."),c.a.createElement(l.MDXTag,{name:"p",components:n},"The first of these is extremely simple due to the functional design of f.js:"),c.a.createElement(l.MDXTag,{name:"pre",components:n},c.a.createElement(l.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'let container = f.div ( f.classList("container") )\n')),c.a.createElement(l.MDXTag,{name:"p",components:n},"Such styled components can be used just like normal f.js dom functions, with\nthe exception that the attributes are ommited."),c.a.createElement(l.MDXTag,{name:"pre",components:n},c.a.createElement(l.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'let view = model =>\n  container\n    ( f.b ()\n      ( "Nice" ) )\n')),c.a.createElement(l.MDXTag,{name:"p",components:n},"Complex components are useful for rendering commonly repeated components. For\nexample, the fotllowing ",c.a.createElement(l.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"product")," component will render a simple div containing\nthe products name and description."),c.a.createElement(l.MDXTag,{name:"pre",components:n},c.a.createElement(l.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'let product = p =>\n  f.div\n    ( f.classList("product") )\n    ( f.b () (p.name)\n    , f.p () (p.description) )\n')),c.a.createElement(l.MDXTag,{name:"p",components:n},"Notice the argument ",c.a.createElement(l.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"p")," used. This allows a seperate, scoped model to be passed\nto the function. In this example, an array of products is rendered using this\ncustom component:"),c.a.createElement(l.MDXTag,{name:"pre",components:n},c.a.createElement(l.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js"}},'let view = model =>\n  f.div\n    ()\n    (model.products.map(p => product(p)))\n\nlet update = (e, m, b) => m\n\nf.render("#app", view, update, {\n  products: [\n    {\n      name: "Foo",\n      description: "Foo Description"\n    },\n    {\n      name: "Bar",\n      description: "Bar Description"\n    }\n  ]\n})\n')))}}]),n}(c.a.Component);d.isMDXComponent=!0}}]);
//# sourceMappingURL=guide.31a4324873b6a1084827.js.map